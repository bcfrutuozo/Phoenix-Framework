#!/usr/bin/env python3
# scripts/generate_unicode_case.py
#
# Gera headers C++:
#  - src/text/UnicodeCase_generated.hpp
#  - src/text/UnicodeCase_special.hpp
#  - src/text/UnicodeCase_props.hpp
#  - src/text/UnicodeCase_utils.hpp
#
# Baixa UnicodeData.txt e SpecialCasing.txt se não existirem.
#
# Requer Python 3.7+

import os
import sys
import urllib.request
from collections import defaultdict

# --- CONFIG ---
UCD_BASE = "https://www.unicode.org/Public/UCD/latest/ucd"
UNICODE_DATA = "UnicodeData.txt"
SPECIAL_CASING = "SpecialCasing.txt"
DERIVED_NORMALIZATION_PROPS = "DerivedNormalizationProps.txt"
NORMALIZATION_CORRECTIONS = "NormalizationCorrections.txt"
OUT_DIR = os.path.join("src", "text")
OUT_GEN = os.path.join(OUT_DIR, "UnicodeCase_generated.hpp")
OUT_SPEC = os.path.join(OUT_DIR, "UnicodeCase_special.hpp")
OUT_PROPS = os.path.join(OUT_DIR, "UnicodeCase_props.hpp")
OUT_UTILS = os.path.join(OUT_DIR, "UnicodeCase_utils.hpp")
# ---------------

def fetch_if_missing(name):
    if os.path.exists(name):
        print(f"{name}: exists, skipping download.")
        return
    urls = [ f"{UCD_BASE}/{name}" ]
    for url in urls:
        try:
            print(f"Downloading {name} from {url} ...")
            urllib.request.urlretrieve(url, name)
            print("done.")
            return
        except Exception as e:
            print(f"failed: {e}")
    raise RuntimeError(f"Could not download {name}")

def parse_unicode_data(path):
    """
    Parses UnicodeData.txt lines.
    Returns:
      - upper_map: dict cp -> mapped cp (first item from field 12)
      - lower_map: dict cp -> mapped cp (field 13)
      - category: dict cp -> General Category string (field 2)
      - simple_title_map not needed here
    """
    upper_map = {}
    lower_map = {}
    category = {}
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.split("#", 1)[0].strip()
            if not line:
                continue
            fields = line.split(";")
            cp = int(fields[0], 16)
            gc = fields[2]
            category[cp] = gc
            upper_field = fields[12].strip()
            lower_field = fields[13].strip()
            if upper_field:
                # pick first code point if sequence
                first = int(upper_field.split()[0], 16)
                upper_map[cp] = first
            if lower_field:
                first = int(lower_field.split()[0], 16)
                lower_map[cp] = first
    return upper_map, lower_map, category

def parse_special_casing(path):
    """
    Parse SpecialCasing.txt
    Returns list of (cp, lower_seq, upper_seq, condition_str)
    """
    entries = []
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.split("#",1)[0].strip()
            if not line: continue
            parts = [p.strip() for p in line.split(";")]
            if len(parts) < 4:
                continue
            cp = int(parts[0], 16)
            lower_seq = tuple(int(x,16) for x in parts[1].split() if x)
            title_seq = tuple(int(x,16) for x in parts[2].split() if x)
            upper_seq = tuple(int(x,16) for x in parts[3].split() if x)
            cond = parts[4].strip() if len(parts) > 4 else ""
            entries.append((cp, lower_seq, upper_seq, cond))
    return entries

def build_props(category_map, special_entries):
    """
    Build arrays for:
      - LETTERS: any General Category starting with 'L'
      - CASED: codepoints with uppercase != lowercase (heuristic)
      - SOFT_DOTTED: from special entries condition 'Soft_Dotted' or from data heuristics
    """

    letters = []
    for cp, gc in category_map.items():
        if gc.startswith("L"):
            letters.append(cp)
    letters.sort()

    # cased: determine by existence in uppercase/lowercase maps or in special entries
    # We'll simply mark those cp that appear in special entries or have different upper/lower mapping (later)
    # For now, we will compute cased from special entries (special may contain conditional) + presence of Upper/Lower map differences will be added by caller
    # But to make self-contained, caller merges after parse.
    # We'll return empty cased list to be filled later by writer since it needs upper_map/lower_map
    soft_dotted = set()
    for cp, lower_seq, upper_seq, cond in special_entries:
        if "Soft_Dotted" in cond:
            soft_dotted.add(cp)
    soft_list = sorted(soft_dotted)
    return letters, soft_list

def emit_generated_header(upper_map, lower_map):
    os.makedirs(OUT_DIR, exist_ok=True)
    with open(OUT_GEN, "w", encoding="utf-8") as out:
        out.write("// Auto-generated: UnicodeCase_generated.hpp\n")
        out.write("// Generated by scripts/generate_unicode_case.py\n\n")
        out.write("#pragma once\n\n")
        out.write("#include <cstdint>\n#include <cstddef>\n\nnamespace UnicodeCase {\n\n")
        out.write("struct MapPair { uint32_t cp; uint32_t mapped; };\n\n")

        # write upper map
        items = sorted(upper_map.items())
        out.write(f"static constexpr MapPair UPPER_MAP[{len(items)}] = {{\n")
        for cp, mp in items:
            out.write(f"    {{ 0x{cp:04X}, 0x{mp:04X} }},\n")
        out.write("};\n\n")

        # write lower map
        items2 = sorted(lower_map.items())
        out.write(f"static constexpr MapPair LOWER_MAP[{len(items2)}] = {{\n")
        for cp, mp in items2:
            out.write(f"    {{ 0x{cp:04X}, 0x{mp:04X} }},\n")
        out.write("};\n\n")

        # binary search find (constexpr)
        out.write(r"""constexpr std::size_t map_find(const MapPair* arr, std::size_t n, uint32_t cp) noexcept {
    std::size_t lo = 0, hi = n;
    while (lo < hi) {
        std::size_t mid = (lo + hi) >> 1;
        uint32_t m = arr[mid].cp;
        if (m == cp) return mid + 1; // found -> index+1
        if (m < cp) lo = mid + 1;
        else hi = mid;
    }
    return 0;
}

constexpr uint32_t to_upper_simple(uint32_t cp) noexcept {
    std::size_t idx = map_find(UPPER_MAP, sizeof(UPPER_MAP)/sizeof(UPPER_MAP[0]), cp);
    if (idx) return UPPER_MAP[idx-1].mapped;
    return cp;
}

constexpr uint32_t to_lower_simple(uint32_t cp) noexcept {
    std::size_t idx = map_find(LOWER_MAP, sizeof(LOWER_MAP)/sizeof(LOWER_MAP[0]), cp);
    if (idx) return LOWER_MAP[idx-1].mapped;
    return cp;
}
""")
        out.write("\n} // namespace UnicodeCase\n")
    print("Wrote", OUT_GEN)

def emit_special_header(special_entries):
    import json

    with open(OUT_SPEC, "w", encoding="utf-8") as out:
        out.write("// Auto-generated: UnicodeCase_special.hpp\n")
        out.write("// Generated by scripts/generate_unicode_case.py\n\n")
        out.write("#pragma once\n#include <cstdint>\n#include <cstddef>\n\nnamespace UnicodeCase {\n\n")
        out.write("struct SpecialEntry { uint32_t cp; const uint32_t* lower; std::size_t lower_len; const uint32_t* upper; std::size_t upper_len; const char* condition; };\n\n")

        for i,(cp, lower_seq, upper_seq, cond) in enumerate(special_entries):

            # Generate LOWER array
            if lower_seq:
                out.write(
                    f"static constexpr uint32_t SLOW_{i}[] = {{ "
                    + ", ".join(f"0x{x:04X}" for x in lower_seq)
                    + " };\n"
                )
            else:
                # no empty arrays
                out.write(f"static constexpr uint32_t SLOW_{i}[] = {{ 0xFFFFFFFF }};\n")

            # Generate UPPER array
            if upper_seq:
                out.write(
                    f"static constexpr uint32_t SUP_{i}[] = {{ "
                    + ", ".join(f"0x{x:04X}" for x in upper_seq)
                    + " };\n"
                )
            else:
                out.write(f"static constexpr uint32_t SUP_{i}[] = {{ 0xFFFFFFFF }};\n")

        out.write("\nstatic constexpr SpecialEntry SPECIAL_ENTRIES[] = {\n")

        for i,(cp, lower_seq, upper_seq, cond) in enumerate(special_entries):
            cond_escaped = json.dumps(cond)[1:-1]
            out.write(
                f"    {{ 0x{cp:04X}, "
                f"SLOW_{i}, sizeof(SLOW_{i})/sizeof(SLOW_{i}[0]), "
                f"SUP_{i}, sizeof(SUP_{i})/sizeof(SUP_{i}[0]), "
                f"\"{cond_escaped}\" }},\n"
            )

        out.write("};\n\n} // namespace UnicodeCase\n")
    print("Wrote", OUT_SPEC)

def emit_props_header(letters_list, cased_list, soft_list):
    with open(OUT_PROPS, "w", encoding="utf-8") as out:
        out.write("// Auto-generated: UnicodeCase_props.hpp\n")
        out.write("// Generated by scripts/generate_unicode_case.py\n\n")
        out.write("#pragma once\n#include <cstdint>\n#include <cstddef>\n\nnamespace UnicodeCase {\n\n")
        out.write(f"static constexpr uint32_t LETTERS[{len(letters_list)}] = {{\n")
        for x in letters_list:
            out.write(f"    0x{x:04X},\n")
        out.write("};\n\n")

        out.write(f"static constexpr uint32_t CASED[{len(cased_list)}] = {{\n")
        for x in cased_list:
            out.write(f"    0x{x:04X},\n")
        out.write("};\n\n")

        out.write(f"static constexpr uint32_t SOFT_DOTTED[{len(soft_list)}] = {{\n")
        for x in soft_list:
            out.write(f"    0x{x:04X},\n")
        out.write("};\n\n")

        out.write(r"""
constexpr bool small_binsearch_has(const uint32_t* arr, std::size_t n, uint32_t cp) noexcept {
    std::size_t lo = 0, hi = n;
    while (lo < hi) {
        std::size_t mid = (lo + hi) >> 1;
        uint32_t v = arr[mid];
        if (v == cp) return true;
        if (v < cp) lo = mid + 1;
        else hi = mid;
    }
    return false;
}
""")
        out.write("\n} // namespace UnicodeCase\n")
    print("Wrote", OUT_PROPS)

def emit_utils_header():
    """
    This header uses the generated arrays and special entries.
    It implements:
      - locale_is_turkic(locale)
      - is_letter(cp)
      - is_cased_or_soft_dotted(cp)
      - apply_final_sigma_context(context_vector, index)
      - map_to_upper_sequence(cp, locale, context_vector)
      - map_to_lower_sequence(...)
    The header uses <vector> and std types for convenience.
    """
    with open(OUT_UTILS, "w", encoding="utf-8") as out:
        out.write("// Auto-generated: UnicodeCase_utils.hpp (depends on generated headers)\n")
        out.write("#pragma once\n\n")
        out.write("#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <string>\n#include \"UnicodeCase_generated.hpp\"\n#include \"UnicodeCase_special.hpp\"\n#include \"UnicodeCase_props.hpp\"\n\nnamespace UnicodeCase {\n\ninline bool locale_is_turkic(const std::string& locale) noexcept {\n    if (locale.size() >= 2) {\n        if (locale.rfind(\"tr\", 0) == 0) return true;\n        if (locale.rfind(\"az\", 0) == 0) return true;\n    }\n    return false;\n}\n\ninline bool is_letter(uint32_t cp) noexcept {\n    return small_binsearch_has(LETTERS, sizeof(LETTERS)/sizeof(LETTERS[0]), cp);\n}\n\ninline bool is_cased(uint32_t cp) noexcept {\n    return small_binsearch_has(CASED, sizeof(CASED)/sizeof(CASED[0]), cp);\n}\n\ninline bool is_soft_dotted(uint32_t cp) noexcept {\n    return small_binsearch_has(SOFT_DOTTED, sizeof(SOFT_DOTTED)/sizeof(SOFT_DOTTED[0]), cp);\n}\n\n// Final sigma context: return true if we should use final-sigma mapping (i.e., produce SMALL FINAL SIGMA)\ninline bool apply_final_sigma_context(const std::vector<uint32_t>& cps, size_t i) noexcept {\n    // Look backwards for a cased letter; look forwards for a letter\n    bool foundBefore = false;\n    if (i > 0) {\n        for (size_t j = i; j-- > 0;) {\n            if (is_cased(cps[j])) { foundBefore = true; break; }\n        }\n    }\n    bool foundAfter = false;\n    for (size_t j = i + 1; j < cps.size(); ++j) {\n        if (is_letter(cps[j])) { foundAfter = true; break; }\n    }\n    // If there is a cased letter before AND a letter after => medial sigma -> NOT final\n    // final sigma when NOT (foundBefore && foundAfter)\n    return !(foundBefore && foundAfter);\n}\n\n// Map cp to upper sequence (returns vector of codepoints)\ninline std::vector<uint32_t> map_to_upper_sequence(uint32_t cp, const std::string& locale, const std::vector<uint32_t>& context) {\n    // Check special entries first (linear scan; small fraction)\n    for (const auto& e : SPECIAL_ENTRIES) {\n        if (e.cp != cp) continue;\n        // condition empty -> unconditional\n        if (!e.condition || e.condition[0] == '\\0') {\n            std::vector<uint32_t> out(e.upper, e.upper + e.upper_len);\n            if (!out.empty()) return out;\n            break; // fallback\n        }\n        std::string cond(e.condition);\n        if (cond.find(\"Final_Sigma\") != std::string::npos) {\n            // need context index; caller must pass context with current codepoint placed at position i ???\n            // We cannot evaluate here without index; caller should instead detect 'σ' (0x03C3) special-case.\n            // Fallback: ignore conditional here and use simple mapping; the String-level code will call apply_final_sigma_context.\n        }\n        if (cond.find(\"Turkic\") != std::string::npos || cond.find(\"AZ\") != std::string::npos) {\n            if (locale_is_turkic(locale)) {\n                std::vector<uint32_t> out(e.upper, e.upper + e.upper_len);\n                return out;\n            }\n            // else skip\n        }\n        // other conditions ignored here\n    }\n    // fallback to simple mapping\n    uint32_t mapped = to_upper_simple(cp);\n    return std::vector<uint32_t>(1, mapped);\n}\n\ninline std::vector<uint32_t> map_to_lower_sequence(uint32_t cp, const std::string& locale, const std::vector<uint32_t>& context) {\n    for (const auto& e : SPECIAL_ENTRIES) {\n        if (e.cp != cp) continue;\n        if (!e.condition || e.condition[0] == '\\0') {\n            std::vector<uint32_t> out(e.lower, e.lower + e.lower_len);\n            if (!out.empty()) return out;\n            break;\n        }\n        std::string cond(e.condition);\n        if (cond.find(\"Final_Sigma\") != std::string::npos) {\n            // same caveat as above\n        }\n        if (cond.find(\"Turkic\") != std::string::npos) {\n            if (locale_is_turkic(locale)) {\n                std::vector<uint32_t> out(e.lower, e.lower + e.lower_len);\n                return out;\n            }\n            // else skip\n        }\n    }\n    uint32_t mapped = to_lower_simple(cp);\n    return std::vector<uint32_t>(1, mapped);\n}\n\n} // namespace UnicodeCase\n")
    print("Wrote", OUT_UTILS)

def main():
    print("Starting generation...")
    fetch_if_missing(UNICODE_DATA)
    fetch_if_missing(SPECIAL_CASING)
    fetch_if_missing(DERIVED_NORMALIZATION_PROPS)
    fetch_if_missing(NORMALIZATION_CORRECTIONS)
    print("Parsing UnicodeData...")
    upper_map, lower_map, category_map = parse_unicode_data(UNICODE_DATA)
    print("Parsing SpecialCasing...")
    special_entries = parse_special_casing(SPECIAL_CASING)

    # Build letters list and soft-dotted
    letters_list, soft_list = build_props(category_map, special_entries)

    # Build CASED list by detecting cp where upper_map[cp] != lower_map[cp] OR cp in special_entries
    cased_set = set()
    for cp in set(list(upper_map.keys()) + list(lower_map.keys())):
        up = upper_map.get(cp, cp)
        lo = lower_map.get(cp, cp)
        if up != lo:
            cased_set.add(cp)
    for cp, lower_seq, upper_seq, cond in special_entries:
        cased_set.add(cp)
    cased_list = sorted(cased_set)

    print("Emitting files...")
    emit_generated_header(upper_map, lower_map)
    emit_special_header(special_entries)
    emit_props_header(letters_list, cased_list, soft_list)
    emit_utils_header()
    print("All done. Headers are in", OUT_DIR)

if __name__ == "__main__":
    main()